#spring boot프로젝트 만들기(tomcat + db(option))
1)spring boot설정시 기본 라이브러리 선택
spring boot devtools(자동리로드)
lombok(get,set)
spring data jpa(db)
spring data jdbc(db)
h2 database(db server)
spring security(login)
spring web(web mvc)
thymeleaf(html view)

2)컨트롤러 작성
@Controller
public class MainController {
@GetMapping("index")
public String index() {
return "index"; //index.jsp ->타임리프라이브러리 추가 -> resources/templates/index.html
}
}

3)resources/templates/index.html 파일 생성

4)spring boot build방법 및 실행방법
mvn package (mvn install -DskipTests)
빌드 후 target폴더아래에 www-0.0.1-SNAPSHOT.jar 생성

시작하는 방법
java -jar target/www-0.0.1-SNAPSHOT.jar
mvnw spring-boot:run (./gradlew bootRun)

5)localhost:8888/index 확인
로그인창나옴(이 창이 활성되는 이유는 sercurity 라이브러리)
해결방법)application.properties
spring.security.user.name=admin 
비밀번호는 콘솔창에 있음
비번번호를 변경하고 싶은 경우
spring.security.user.password=1234

서버포트 문제발생)application.properties
server.port=8888

6)localhost:8888/h2-console실행
문제발생) 연결오류는 보안문제(sercurity 라이브러리) 또는 아래 파일의 없음
window사용시 c:\users/username/test.mv.db 파일생성
보안문제는 security를 주석처리

브라우저를 반드시 다시 실행해야함.

7)jsp파일을 사용하기 원하는 경우
타임리프 주석처리, 타임리프의 파일 위치는 resources/templates
서버를 완전 중지 후 다시 실행

localhost:8888/index.jsp -> main/webapp/index.jsp
하지만 pom.xml 아래 라이브러리가 필요
<dependency>
<groupId>org.apache.tomcat.embed</groupId>
<artifactId>tomcat-embed-jasper</artifactId>
</dependency>

#타임리프 없이 viewresolver jsp를 적용하기를 원하는 경우
application.propertes파일에
spring.mvc.view.prefix=/WEB-INF/
spring.mvc.view.suffix=.jsp
파일의 위치는 main/webapp/WEB-INF/index.jsp위치해야함

#css, js파일의 위치(resources/static 폴더 아래 위치)
타임리프를 주석해제하고 타임리프로 처리
<link href="/css/style.css" rel="stylesheet">
resources/static/css/style.css

<script src="/js/main.js"></script>
resources/static/js/main.js

#사용자 변수는 application.properties에서 정의
url.index=/index
클래스에서 사용은 다음과 같이 @GetMapping("${url.index}")
문제)application.properties파일 대신 url설정파일을 별도로 작성하여 관리하고 싶은 경우 어떻게 해야하나?

##데이터베이스 JPA활용하기
application.properties
#db접속정보를 입력하여 DataSource생성하는데 필요(db접속)
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:~/test
spring.datasource.username=sa
spring.datasource.password=
#JPA를 이용하기 위한 정보
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.show_sql=true

#DAO역할, extends JpaRepository 구현
public interface PersonJPA extends JpaRepository<Person, Integer>{

}

@Data //get, set
@Entity //Error creating bean with name 'personJPA' defined in PersonJPA오류발생원인, bean생성 및 테이블 연결
//@Table
public class Person {
	@Id
	@GeneratedValue
	private Integer id;
	private String name;
	private String email;
}

#테스트하기
@SpringBootApplication
public class BackendApplication implements CommandLineRunner{

@Autowired
PersonJPA jpa;
	
public static void main(String[] args) {
SpringApplication.run(BackendApplication.class, args);
}
@Override
public void run(String... args) throws Exception {
System.out.println(jpa.findAll()); //수행확인, 만약 @로 나올 경우 아래코드를 참고하여 lombok설치 확인
//lombok설치 확인
for(Person p:jpa.findAll()) {
System.out.println(p.getEmail());
}
}

#restapi작성
@RestController
@RequestMapping("/api")
public class PersonAPI {

	@Autowired
	PersonJPA personJpa;
	
	/*
	@GetMapping("persons")
	public List<Person> getPersons(){
		return personJpa.findAll(); 
	}
	*/
	
	@GetMapping("persons")
	public ResponseEntity<List<Person>> getPersons() {
	    List<Person> persons = personJpa.findAll();
	    if (persons.isEmpty()) {
	        return ResponseEntity.noContent().build(); // 204 No Content if no persons found
	    }
	    return ResponseEntity.ok(persons); // 200 OK with the list of persons
	}

}

##전체출력,선택출력,  수정, 삭제, 여러개 입력등에 관한 테스트
@Override
public void run(String... args) throws Exception {
/*전체출력*/
System.out.println(jpa.findAll());
		
//lombok설치 확인, 설치안되어 있을 경우 get함수 안 나타남
p.getEmail();
		
		
/*시나리오
1)자동증가하는 id에 값을 입력하여 처리 - 오류발생(unsaved-value mapping was incorrect)
2)id를 제외하고 입력처리 - 성공(auto_increment가 있을 경우 id는 제외)
3)id를 제외하고 입력처리 후 전체보기 실행 - 오류발생할 수도 있음
*/
		
Person p=new Person();
//p.setId(200);
p.setName("sangsu500");
p.setEmail("sangsu500@gmail.com");
jpa.save(p);
System.out.println(jpa.findAll());
		
//삭제
jpa.deleteById(352);
System.out.println(jpa.findAll());

//여러개의 id를 입력하여 삭제(302,252,200,152,102,52)
//리스트를 사용하는 여러방법
List<Integer> ids=Arrays.asList(new Integer(302),new Integer(252));
List<Integer> ids=Arrays.asList(200,152);
int[] ids= {152,102,52};
jpa.deleteAllById(Arrays.stream(ids).boxed().collect(Collectors.toList()));
System.out.println(jpa.findAll());
		
//수정 : id가 db에 입력되어 있는 상태여야하며 없을 경우 단순입력으로 처리, 입력처리하고 같음
//기존의 데이터를 불러와서 변경되는 값에 대해서만 수정하고 다른값은 동일하게 입력처
Person p=new Person();
p.setId(1);
p.setName("hongkildong1");
//p.setEmail("hong@gmail.com");//주석처리할 경우 오류 발생
jpa.save(p);
System.out.println(jpa.findAll());

//위의 문제를 해결하는 방법(필요한 값만을 수정하는 방법)
System.out.println(jpa.findById(1)); //Optional형태(Person객체가 아니라는 의미)
System.out.println(jpa.findById(1).get().getName());
		
Person p=jpa.findById(1).get();
p.setName("홍길동");
jpa.save(p);
System.out.println(jpa.findAll());

//optional을 사용하는 이유는 검색한 데이터가 존재할 수도, 안 할수도 있기 때문
if(jpa.findById(1).isEmpty()) {
System.out.println("검색한 데이터가 존재하지 않습니다.!");
}else {
System.out.println("검색한 데이터가 존재합니다.!");
}

		
//시나리오. 객체리스트로 여러명의 데이터가 존재하는 경우 한번에 데이터를 입력처리방법
List<Person> list=new ArrayList<>();
//id는 넣을 수 없는 상태, id를 제외한 필드생성자를 생성해야하지만 대신하여 build처리@Builder
//list.add(new Person("user1","1234")); 코드 대신 아래 builder사용
for(int i=1;i<10;i++)
list.add(Person.builder().name("user"+i).email("user"+i+"@gmail.com").build());
System.out.println(list);
		
jpa.saveAll(list);
		
System.out.println(jpa.findAll()); 
//오류발생, 원인은 동시에 db사용관련 트랙잭션오류발생
}

#respapi완성
methd get, post, put, delete방식으로 구현하기
@RestController
@RequestMapping("/api")
public class PersonAPI {

	@Autowired
	PersonJPA personJpa;
	
	
	@GetMapping("persons")
	public List<Person> getPersons(){
		return personJpa.findAll(); 
	}
	
	@GetMapping("person/{id}") //person 1번 id를 표시할 경우 person/1
	//@RequestParam /api/person?id=1
	//@RequestAttribute 클래스 함수의 파라메다를 들고오는 속성
	//@PathVariable /api/person/1
	public Person getPerson(@PathVariable Integer id){
		return personJpa.findById(id).get(); 
	}
	
	//http://localhost:8888/api/person?id=1
	@GetMapping("person")
	public Person getPersonParam(@RequestParam Integer id){
		return personJpa.findById(id).get(); 
	}
	
	//curl or javascript ajax로 확인
	//curl -v -X DELETE http://localhost:8888/api/person/1 
	//curl사용시 method는 대문자를 사용
	@DeleteMapping("person/{id}")
	public String deletePerson(@PathVariable Integer id){
		personJpa.deleteById(id);
		return "삭제성공";
	}
	
	//입력
	/* 
	 curl -v -X POST http://localhost:8888/api/person 
	 -H "Content-Type:application/json"
	 -d "{\"name\":\"user100\",\"email\":\"user100@gmail.com\"}"
	 */
	@PostMapping("person")
	public String postPerson(@RequestBody Person person) {
		personJpa.save(person);
		return "입력성공";
	}
	
	
	//수정
	/* 
	 curl -v -X PUT http://localhost:8888/api/person 
	 -H "Content-Type:application/json"
	 -d "{\"id\":603,\"name\":\"user\",\"email\":\"user@gmail.com\"}"
	 */
	@PutMapping("person")
	public String putPerson(@RequestBody Person person){
		Person dbperson=personJpa.findById(person.getId()).get();
		//수정하려는 person에 데이터가 null일 경우 dbperson을 그대로 사용 
		if(person.getName()!=null) dbperson.setName(person.getName());
		if(person.getEmail()!=null) dbperson.setEmail(person.getEmail());
		personJpa.save(dbperson);
		return "수정성공";
	}
	
	
	
	/*
	@GetMapping("persons")
	public ResponseEntity<List<Person>> getPersons() {
	    List<Person> persons = personJpa.findAll();
	    if (persons.isEmpty()) {
	        return ResponseEntity.noContent().build(); // 204 No Content if no persons found
	    }
	    return ResponseEntity.ok(persons); // 200 OK with the list of persons
	}
	*/

}

curl -v -X POST http://localhost:8888/api/person -H "Content-Type:application/json" -d "{\"name\":\"user\",\"email\":\"user@gmail.com\"}"

#아래코드 오류(원인 id가 숫자)
curl -v -X PUT http://localhost:8888/api/person  -H "Content-Type:application/json" -d "{\"id\":\"603\",\"name\":\"user\",\"email\":\"user@gmail.com\"}"

curl -v -X PUT http://localhost:8888/api/person  -H "Content-Type:application/json" -d "{\"id\":603,\"name\":\"user\",\"email\":\"user@gmail.com\"}"


#fetch를 이용한 구현
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<link href="/css/style.css" rel="stylesheet">
<script src="/js/main.js"></script>
<script>
//fetch는 동기방식(순서적으로 처리)
/*
fetch("http://localhost:8888/api/person/2", {
	  method: "DELETE",
	})
	  .then(response => {
	    if (response.ok) {
	      return response.text(); // 서버가 문자열 반환 시
	    } else {
	      throw new Error("삭제 실패! 상태 코드: " + response.status);
	    }
	  })
	  .then(data => {
	    console.log("서버 응답:", data);
	    document.querySelector("body").textContent=data;
	  })
	  .catch(error => {
	    console.error("에러 발생:", error);
	    document.querySelector("body").textContent=error;
	  });
*/
//동기 방식이기하지만 비동기처리
/*
deletePerson(2);
async function deletePerson(id) {
	  try {
	    const response = await fetch(`http://localhost:8888/api/person/${id}`, 
	    	{method: "DELETE",}
	    );

	    if (!response.ok) {
	      throw new Error(`삭제 실패! 상태 코드: ${response.status}`);
	    }

	    const result = await response.text(); // 서버가 text 반환 시
	    console.log("삭제 성공:", result);
	  } catch (error) {
	    console.error("에러 발생:", error.message);
	  }
	}
*/

//입력 javascript
// "{\"name\":\"user100\",\"email\":\"user100@gmail.com\"}" 문자열에 대한 json형식
/*
const person={name:"user1000",email:"user1000@gmail.com"}; //객체

fetch("http://localhost:8888/api/person", {
	  method: "POST",
	  headers : {"Content-Type":"application/json"},
	  body : JSON.stringify(person)
	})
	  .then(response => {
	    if (response.ok) {
	      return response.text(); // 서버가 문자열 반환 시
	    } else {
	      throw new Error("입력 실패! 상태 코드: " + response.status);
	    }
	  })
	  .then(data => {
	    console.log("서버 응답:", data);
	    document.querySelector("body").textContent=data;
	  })
	  .catch(error => {
	    console.error("에러 발생:", error);
	    document.querySelector("body").textContent=error;
	  });
	  */
	  /*
	  const person={id:560, name:"user1000",email:"user1000@gmail.com"}; //객체

	  fetch("http://localhost:8888/api/person", {
	  	  method: "PUT",
	  	  headers : {"Content-Type":"application/json"},
	  	  body : JSON.stringify(person)
	  	})
	  	  .then(response => {
	  	    if (response.ok) {
	  	      return response.text(); // 서버가 문자열 반환 시
	  	    } else {
	  	      throw new Error("입력 실패! 상태 코드: " + response.status);
	  	    }
	  	  })
	  	  .then(data => {
	  	    console.log("서버 응답:", data);
	  	    document.querySelector("body").textContent=data;
	  	  })
	  	  .catch(error => {
	  	    console.error("에러 발생:", error);
	  	    document.querySelector("body").textContent=error;
	  	  });
	  */
	  
	  fetch("http://localhost:8888/api/persons", {
		  method: "get",
		})
		  .then(response => {
		    if (response.ok) {
		      return response.json(); 
		    } else {
		      throw new Error("삭제 실패! 상태 코드: " + response.status);
		    }
		  })
		  .then(data => {
		    console.log("서버 응답:", data);
		    //document.querySelector("body").textContent=data;
		    const root=document.querySelector("body");
		    
		    for(i=0;i<data.length;i++){
			content="<ul>" +
			"<li>" + data[i]["id"]    + "</li>" +
			"<li>" + data[i]["name"]  + "</li>" +
			"<li>" + data[i]["email"] + "</li>" +
			"</ul>";
			root.innerHTML+=content;
		    }
		    
		  })
		  .catch(error => {
		    console.error("에러 발생:", error);
		    document.querySelector("body").textContent=error;
		  });
</script>
</head>
<body>
index.html
</body>
</html>


#restapi를 작성 후에 front사용하는 구성
springboot tomcat 서버에 front(index.html)+backend(restapi)

front server(nginx/html)
+proxy+
back end(tomcat/restapi)


fetch("주소",{정보}).then( ).then( ).catch( );

fetch("주소",{정보})
.then( resp=> resp.text())
.then( text =>{ text처리 })
.catch( );

fetch("주소",{정보})
.then( (resp)=>{ return resp.text() })
.then( (text)=>{  text값을 사용 })
.catch( );

##테이블 자동 생성
@Table //테이블 생성
//@Builder //api사용시 builder를 사용할 경우 500에러 발생
public class Person { }

##h2 database에서 테이블 삭제 및 시퀸스 삭제
drop table person;
DROP SEQUENCE IF EXISTS PERSON_SEQ;

@Id
@GeneratedValue //이코드 역할이 자동으로 시킨스를 생성하는 역할
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "person_seq")
@SequenceGenerator(name = "person_seq", sequenceName = "person_seq", allocationSize = 1)
private Integer id;

예제) spring boot에서 프로젝트를 새로 생성하고
사용자를 저장할 객체를 생성하고 오라클에서 자동으로 테이블이 생성되도록 코드를 작성하고 
입력, 전체출력, 선택출력, 수정, 삭제에 관한 api를 작성하시오.
Member 객체 : id(번호), username, password, email, role 필드

##수정된 코드 (ResponseEntity 사용)
@RestController
@RequestMapping("/api")
public class PersonAPI {

    @Autowired
    PersonJPA personJpa;

    // 전체 목록 조회
    @GetMapping("persons")
    public ResponseEntity<List<Person>> getPersons() {
        List<Person> persons = personJpa.findAll();
        return ResponseEntity.ok(persons);
    }

    // ID로 조회 (PathVariable)
    @GetMapping("person/{id}")
    public ResponseEntity<Person> getPerson(@PathVariable Integer id) {
        return personJpa.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // ID로 조회 (RequestParam)
    @GetMapping("person")
    public ResponseEntity<Person> getPersonParam(@RequestParam Integer id) {
        return personJpa.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // 삭제
    @DeleteMapping("person/{id}")
    public ResponseEntity<Void> deletePerson(@PathVariable Integer id) {
        if (personJpa.existsById(id)) {
            personJpa.deleteById(id);
            return ResponseEntity.noContent().build();  // 204 No Content
        } else {
            return ResponseEntity.notFound().build();   // 404 Not Found
        }
    }

    // 등록
    @PostMapping("person")
    public ResponseEntity<String> postPerson(@RequestBody Person person) {
        personJpa.save(person);
        return ResponseEntity.status(HttpStatus.CREATED).body("입력성공");
    }

    // 수정
    @PutMapping("person")
    public ResponseEntity<String> putPerson(@RequestBody Person person) {
        return personJpa.findById(person.getId())
                .map(dbPerson -> {
                    if (person.getName() != null) dbPerson.setName(person.getName());
                    if (person.getEmail() != null) dbPerson.setEmail(person.getEmail());
                    personJpa.save(dbPerson);
                    return ResponseEntity.ok("수정성공");
                })
                .orElse(ResponseEntity.status(HttpStatus.NOT_FOUND).body("해당 ID를 찾을 수 없습니다"));
    }
}






